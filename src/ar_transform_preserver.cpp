/*
* Parameters: Several parameters can be set using private ros parameters ---
*	kinect_frame: The frame of the pointcloud used in your application (will be preserved).
*	ar_code_frame: The frame generated by the specific AR marker sticker.
*/

#include <ros/ros.h>
#include <tf/transform_listener.h>
#include <tf/transform_broadcaster.h>
#include <pose_file_io.h>
#include <dynamic_reconfigure/Reconfigure.h>
#include <dynamic_reconfigure/Config.h>
#include <dynamic_reconfigure/BoolParameter.h>

#include <unistd.h>

#include <string>
#include <thread>
using std::string;

bool new_calibration = false;

void get_frame_names(string& kinect_frame, string& ar_marker_frame);
void stop_start_calibration();

int main(int argc, char** argv)
{
	ros::init(argc, argv, "ar_transform_republisher");
	ros::NodeHandle nh;

	std::thread calibrator_thread(stop_start_calibration);

	string kinect_frame;
	string ar_marker_frame;
	string world_frame;
	get_frame_names(kinect_frame, ar_marker_frame);

	ROS_INFO_STREAM("Ar frame: " << ar_marker_frame << " Kinect cloud frame: " << kinect_frame);

	tf::TransformListener listener;
	tf::TransformBroadcaster tf_publisher;

	tf::Transform temp;
	int kinect_config_fd = load_transform(temp);
	tf::StampedTransform transform(temp, ros::Time::now(), kinect_frame, ar_marker_frame);
	
	short file_save_counter = 0;
	ros::Rate freq(200);//Hz
	while(ros::ok()){
		try {
			listener.lookupTransform(kinect_frame, ar_marker_frame, ros::Time(0), transform);
			//transform.child_frame_id_ = "/dummy";
			//ROS_INFO("Transform found.");

		} catch(...) {
			// Error, update is out of sync. Skip it and try again
			continue;
		}

		transform.stamp_ = ros::Time::now();
		
		tf_publisher.sendTransform(transform);
		
		if (file_save_counter >= 1000 && new_calibration){
			save_transform(kinect_config_fd, transform);
			file_save_counter = 0;
			ROS_INFO("Saving kinect calibration");
		}

		file_save_counter++;
		freq.sleep();
	}
}

void get_frame_names(string& kinect_frame, string& ar_marker_frame)
{
	if (!ros::param::get("~kinect_frame", kinect_frame)){
		ROS_ERROR("Could not get the kinect's reference frame name. Are you using the standard launch files?");
	}
	

	if (!ros::param::get("~ar_code_frame", ar_marker_frame)){
		ROS_ERROR("Could not get the ar_code_frame in ar_transform_republisher.");
	}
}

void stop_start_calibration()
{
	ROS_INFO("Thread online!");
	ros::NodeHandle nh;
	ros::ServiceClient calibration_srv = nh.serviceClient<dynamic_reconfigure::Reconfigure>("/ar_track_alvar/set_parameters");
	dynamic_reconfigure::Reconfigure srv;
	dynamic_reconfigure::BoolParameter enable_param;
	enable_param.name = "enabled";
	enable_param.value = false;

	srv.request.config.bools.push_back(enable_param);

	//Turn it off initially. I could do this if we forked the repo... But I don't want to
	calibration_srv.call(srv);

	string input;
	string next_state = "on";
	while(1){
		cout << "Please press anything to turn the calibration " << next_state;
		getline(cin, input);

		if (srv.request.config.bools[0].value == true){
			srv.request.config.bools[0].value = false;
			new_calibration = false;
			next_state = "on";
		} else {
			srv.request.config.bools[0].value = true;
			new_calibration = true;
			next_state = "off";
		}
		
		if (!calibration_srv.call(srv)){
			ROS_ERROR("Dynamic configure service not working for ar_code calibration start/stop");
		}
	}

	ROS_ERROR("THREAD EXITED");
}
